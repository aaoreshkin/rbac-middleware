# Система ролевого доступа (RBAC)

## Обзор

Система ролевого доступа использует битовые маски для гибкого управления правами пользователей. Каждая роль представлена отдельным битом, что позволяет комбинировать роли и создавать сложные правила доступа.

## Установка

```bash
go get -u github.com/aaoreshkin/rbac-middleware
```

### Использование

```go
import (
    "github.com/aaoreshkin/rbac-middleware"
)
```

Настройте секретный ключ для JWT:
Мидлварь забирает "SECRET_KEY" из окружения для подписи токена

```go
os.Setenv("SECRET_KEY", "ваш секретный ключ")
```

или используйте окружение .env.sh

```bash
export SECRET_KEY="ваш секретный ключ"
```

или доверьтесь openssl

```bash
export SECRET_KEY="$(openssl rand -base64 32)"
```

## Разрешения и группы

```go
const (
    r int64 = 1 << iota // read:     00001 (1)
    w                   // write:    00010 (2)
    u                   // update:   00100 (4)
    d                   // delete:   01000 (8)
    ...
)
```

| Разрешение | Двоичное представление | Десятичное значение | Описание   |
| ---------- | ---------------------- | ------------------- | ---------- |
| r          | 00001                  | 1                   | Чтение     |
| w          | 00010                  | 2                   | Запись     |
| u          | 00100                  | 4                   | Обновление |
| d          | 01000                  | 8                   | Удаление   |

## Использование

### Комбинирование ролей

Используй побитовое ИЛИ (`|`) для комбинирования ролей:

```go
// Доступ для чтения и записи
r.Use(rbac.Middleware(r | w))

// Доступ для  инженеров и суперпользователей
r.Use(rbac.Middleware(e , s))
```

### Проверка разрешения

Используйте побитовое И (`&`) для проверки наличия разрешения:

```go
// Проверка наличия прав инженера
if userRole & e != 0 {
    // У пользователя есть права инженера
}

// Проверка наличия прав суперпользователя или инженера
if userRole & (s | e) != 0 {
    // У пользователя есть права суперпользователя или инженера
}
```

### Управление ролями

```go
// Добавление роли
userRole |= e  // Добавить права инженера

// Удаление роли
userRole &= ^s  // Удалить права суперпользователя

// Проверка на точное соответствие набору ролей
if userRole == (e | s) {
    // Пользователь имеет разрешения инженера и суперпользователя (и только их)
}
```

### Предопределенные комбинации

Для удобства можно создать предопределенные комбинации ролей:

```go

const (
	v int64 = r             // viewer: read only
	e       = r | w | u     // engineer: read, write, update
	s       = r | w | u | d // superuser: all permissions
)
```

## Пример использования в маршрутах

```go
// Маршруты только для администраторов
r.Group(func(r chi.Router) {
    r.Use(rbac.Middleware(s , e))
    // ...
})

// Публичные маршруты (доступны всем)
r.Group(func(r chi.Router) {
    r.Use(rbac.Middleware(r | w | u | d))
    // ...
})
```

## Преимущества

- Гибкость: легко комбинировать и проверять разрешения
- Эффективность: быстрые битовые операции
- Расширяемость: можно добавить до 64 различных разрешений (при использовании int64)
- Компактность: одно числовое значение содержит информацию о всех разрешениях пользователя

## Создание токена:

```go
token, err := rbac.Hash(map[string]interface{}{
		"id":         c.ID,
		"permission": c.Permission,
	}, timeout)
```

или

```go
type Claims struct {
    ID string `json:"id"`
    Permission int64 `json:"permission"`
}

func (c Claims) ToClaims() map[string]interface{} {
    return map[string]interface{}{
        "id": c.ID,
        "permission": c.Permission,
    }
}

token, err := rbac.Hash(UserClaims{ID: "1", Permission: 15}, timeout)
```
